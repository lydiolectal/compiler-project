(define null-binary-tree (lambda ()()))(define null-bst null-binary-tree )(define make-binary-tree (lambda (element left right )(list element left right )))(define entry (lambda (T )(car T )))(define left (lambda (T )(cadr T )))(define right (lambda (T )(caddr T )))(define binary-tree? (lambda (L )(cond ((equal? L (null-binary-tree ))#t )((pair? L )(and (not (pair? (entry L )))(binary-tree? (left L ))(binary-tree? (right L ))))(else #f ))))(define bst? (lambda (L )(define sorted? (lambda (L2 )(if (= (length L2 )1 )#t (and (< (car L2 )(cadr L2 ))(sorted? (cdr L2 ))))))(and (binary-tree? L )(sorted? (inorder-traverse L )))))(define null-bst? (lambda (T )(if (equal? T (null-bst ))#t #f )))(define member? (lambda (v bst )(cond ((equal? bst (null-binary-tree ))#f )((eqv? (entry bst )v )#t )((> (entry bst )v )(member? v (left bst )))((< (entry bst )v )(member? v (right bst ))))))(define insert (lambda (v bst )(cond ((equal? bst (null-binary-tree ))(list v ()()))((eqv? (entry bst )v )bst )((> (entry bst )v )(list (entry bst )(insert v (left bst ))(right bst )))((< (entry bst )v )(list (entry bst )(left bst )(insert v (right bst )))))))(define inorder-traverse (lambda (T )(if (equal? T (null-binary-tree ))()(append (inorder-traverse (left T ))(list (entry T ))(inorder-traverse (right T ))))))
